{
  "name": "Isokey",
  "tagline": "Self-contained API keys via cryptographic signatures",
  "body": "# Isokey\r\n\r\nIsokey allows you to make and verify self-contained API keys without a database via HMAC signatures.\r\n\r\n## Features\r\n- Important information such as userID, key expire time, and flags are stored within\r\nthe key.\r\n- Use mutliple secrets simultaneously\r\n- Invalidate secrets and compromised keys\r\n\r\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\r\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\r\n## Table Of Contents\r\n\r\n- [Install](#install)\r\n- [Symmetric Keys](#symmetric-keys)\r\n  - [Make a key service](#make-a-key-service)\r\n  - [Make key digest](#make-key-digest)\r\n  - [Verify key](#verify-key)\r\n  - [Using multiple secrets](#using-multiple-secrets)\r\n  - [Digest Structure](#digest-structure)\r\n- [Asymmetric Keys](#asymmetric-keys)\r\n  - [Make a key pair](#make-a-key-pair)\r\n  - [Make key digest](#make-key-digest-1)\r\n  - [Verify key](#verify-key-1)\r\n  - [Using multiple keys](#using-multiple-keys)\r\n  - [Digest Structure](#digest-structure-1)\r\n- [Invalidating keys](#invalidating-keys)\r\n\r\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\r\n\r\n# Install\r\nAlways use gopkg to install, the repository may be in a broken midway state.\r\n\r\n`go get gopkg.in/ammario/isokey.v2`\r\n\r\n# Symmetric Keys\r\n\r\n## Make a key service\r\n```go\r\n    ks := SymKeyService{\r\n\t\tSecret: []byte(\"super_secure111\"),\r\n\t}\r\n```\r\n\r\n##  Make key digest\r\n```go\r\n\tkey := &Key{\r\n\t\tUserID:  1,\r\n\t\tExpires: time.Now().AddDate(0, 1, 0),\r\n\t}\r\n\r\n\tdigest, err := ks.Digest(key)\r\n\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Error making digest: %v\", err)\r\n\t}\r\n\tfmt.Printf(\"Digest is %v\\n\", digest)\r\n```\r\n\r\n## Verify key\r\n\r\n```go\r\n    key, err = ks.Verify(digest)\r\n\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Error reading digest: %v\", err)\r\n\t}\r\n    //Key authenticated\r\n\tfmt.Printf(\"Key: %+v\\n\", key)\r\n```\r\n\r\n## Using multiple secrets\r\nThe SecretVersion is in included in each key to enable\r\nimplementors to use multiple secrets.\r\n\r\nUse a map\r\n```go\r\n    ks.SecretMap = map[uint32][]byte{\r\n        1: []byte(\"sec1\"),\r\n        2: []byte(\"sec2\"),\r\n    }\r\n```\r\n\r\nAlternatively get full control with a function\r\n```go\r\n    ks.GetSecret = function(key *Key)(secret []byte){\r\n        if key.SecretVersion == 1 {\r\n            return []byte(\"sec1\") \r\n        }\r\n        return nil\r\n    }\r\n```\r\n\r\n\r\n\r\n## Digest Structure\r\nAll binary values are big endian.\r\n\r\n| Field | Type |\r\n|--------|------|\r\n| Signature | [16]byte |\r\n| Made Time (Unix epoch timestamp) | uint32 |\r\n| Expire Time (Unix epoch timestamp) | uint32 |\r\n| Secret Version | uint32 |\r\n| User ID     | uint32 |\r\n| Flags | uint32 |\r\n\r\nDigests are encoded with Bitcoin's base58 alphabet.\r\n\r\nIt may seem intuitive to put the signature at the end of the digest. It's located\r\nat the beginning as it makes eyeballing different keys more easy due to\r\nthe avalanche effect.\r\n\r\n# Asymmetric Keys\r\n\r\n## Make a key pair\r\n\r\nMake your private key \r\n`openssl ecparam -genkey -name prime256v1 -outform DER -noout -out privatekey.der`\r\n\r\nMake your public key\r\n`openssl ec -in privatekey.der -inform DER -outform DER -pubout -out publickey.der`\r\n\r\n\r\n## Make key digest\r\n```go\r\n    privKey, _ = isokey.LoadPrivateKey(\"priv.key\")\r\n\r\n    ks := AsymKeySigner{\r\n\t\tPrivateKey: privKey,\r\n\t}\r\n\r\n    key := &Key{\r\n        User: 1,\r\n        Expires: time.Now().Add(time.Hour)\r\n    }\r\n\r\n    digest, _ := ks.Digest(key)\r\n\r\n    fmt.Printf(\"Digest: %v\", digest)\r\n```\r\n\r\n##  Verify key\r\n```go\r\n\tpubKey, _ = isokey.LoadPublicKey(\"pub.key\")\r\n\r\n\tkv := AsymKeyVerifier{\r\n        PublicKey: pubKey,\r\n    }\r\n\r\n    key, err := kv.Verify(digest)\r\n    if err != nil {\r\n        log.Fatalf(\"Error verifying key: %v\", err)\r\n    }\r\n\tfmt.Printf(\"Key verified %v\\n\", key)\r\n\r\n```\r\n\r\n## Using multiple keys\r\nSimilar to symmetric keys, you can use multiple public\r\nor private keys. Refer to the godoc for specific usage.\r\n\r\n\r\n## Digest Structure\r\nAll binary values are big endian.\r\n\r\n| Field | Type |\r\n|--------|------|\r\n| R len     | uint8\r\n| R         | []byte\r\n| S Len     | uint8\r\n| S         | []byte\r\n| Made Time (Unix epoch timestamp) | uint32 |\r\n| Expire Time (Unix epoch timestamp) | uint32 |\r\n| Secret Version | uint32 |\r\n| User ID     | uint32 |\r\n| Flags | uint32 |\r\n\r\nDigests are encoded with Bitcoin's base58 alphabet.\r\n\r\n\r\n# Invalidating keys\r\n\r\nCustom invalidation can be useful if you'd like to support cases where the client\r\nhas been compromised.\r\n\r\nYou can invalidate keys like so\r\n```go\r\nks.CustomInvalidate = function(key *isokey.Key) bool {\r\n    if key.UserID == 10 && key.Made.Before(time.Date(2015, time.November, 10, 23, 0, 0, 0, time.UTC)) {\r\n        return true\r\n    }\r\n    //Make sure to handle expired keys when overriding\r\n    if key.Expires.Before(time.Now()) {\r\n        return true\r\n    }\r\n    return false\r\n}\r\n```\r\n**Remember when overriding Invalidate to handle expired keys**",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}